<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>expression.collections.map API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>expression.collections.map</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Attribution to original authors of this code
# --------------------------------------------
# This code has been originally been ported from the Fable project which
# was originally ported from the FSharp project.
#
# Fable:
#   https://fable.io
# - Copyright (c) Alfonso Garcia-Caro and contributors.
# - MIT License
# - https://github.com/fable-compiler/Fable/blob/nagareyama/src/fable-library/Map.fs
#
# F#
# - https://github.com/dotnet/fsharp
# - Copyright (c) Microsoft Corporation. All Rights Reserved.
# - MIT License
# - https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/map.fs

from typing import (Any, Callable, Generic, Iterable, Iterator, List, Optional,
                    Tuple, TypeVar, Union, cast, overload)

from expression.core import Option, pipe

from . import maptree, seq
from .frozenlist import FrozenList
from .maptree import MapTree

Value = TypeVar(&#34;Value&#34;)
Key = TypeVar(&#34;Key&#34;)
Result = TypeVar(&#34;Result&#34;)
T1 = TypeVar(&#34;T1&#34;)
T2 = TypeVar(&#34;T2&#34;)
T3 = TypeVar(&#34;T3&#34;)
T4 = TypeVar(&#34;T4&#34;)
T5 = TypeVar(&#34;T5&#34;)
T6 = TypeVar(&#34;T6&#34;)


class Map(Generic[Key, Value]):
    def __init__(self, __tree: Optional[MapTree[Key, Value]] = None, **kw: Value) -&gt; None:
        tree: MapTree[str, Value] = maptree.of_seq(kw.items())
        self._tree = __tree if __tree is not None else tree

    @overload
    def pipe(self, __fn1: Callable[[&#34;Map[Key, Value]&#34;], Result]) -&gt; Result:
        ...

    @overload
    def pipe(self, __fn1: Callable[[&#34;Map[Key, Value]&#34;], T1], __fn2: Callable[[T1], T2]) -&gt; T2:
        ...

    @overload
    def pipe(
        self, __fn1: Callable[[&#34;Map[Key, Value]&#34;], T1], __fn2: Callable[[T1], T2], __fn3: Callable[[T2], T3]
    ) -&gt; T3:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;Map[Key, Value]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
    ) -&gt; T4:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;Map[Key, Value]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
    ) -&gt; T5:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;Map[Key, Value]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
        __fn6: Callable[[T5], T6],
    ) -&gt; T6:
        ...

    def pipe(self, *args: Any) -&gt; Any:
        &#34;&#34;&#34;Pipe map through the given functions.&#34;&#34;&#34;
        return pipe(self, *args)

    @staticmethod
    def empty() -&gt; &#34;Map[Key, Value]&#34;:
        return Map(maptree.empty)

    @staticmethod
    def create(ie: Iterable[Tuple[Key, Value]]) -&gt; &#34;Map[Key, Value]&#34;:
        return Map(maptree.of_seq(ie))

    def add(self, key: Key, value: Value) -&gt; &#34;Map[Key, Value]&#34;:
        return Map(maptree.add(key, value, self._tree))

    def change(self, key: Key, f: Callable[[Option[Value]], Option[Value]]) -&gt; &#34;Map[Key, Value]&#34;:
        return Map(maptree.change(key, f, self._tree))

    def is_empty(self) -&gt; bool:
        return maptree.is_empty(self._tree)

    def try_pick(self, chooser: Callable[[Key, Value], Option[Result]]) -&gt; Option[Result]:
        return maptree.try_pick(chooser, self._tree)

    def exists(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
        return maptree.exists(predicate, self._tree)

    def filter(self, predicate: Callable[[Key, Value], bool]) -&gt; &#34;Map[Key, Value]&#34;:
        return Map(maptree.filter(predicate, self._tree))

    def for_all(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
        &#34;&#34;&#34;Returns true if the given predicate returns true for all of
        the bindings in the map.

        Args:
            predicate: The function to test the input elements.

        Returns:
            True if the predicate evaluates to true for all of the
            bindings in the map.
        &#34;&#34;&#34;
        return maptree.forall(predicate, self._tree)

    def iterate(self, f: Callable[[Key, Value], None]) -&gt; None:
        return maptree.iter(f, self._tree)

    #     def MapRange (f:&#39;Value-&gt;&#39;Result) =
    #         return Map&lt;&#39;Key, &#39;Result&gt;(comparer, maptree.map f tree)

    def fold(self, folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) -&gt; Result:
        return maptree.fold(folder, state, self._tree)

    def map(self, mapping: Callable[[Value], Result]) -&gt; &#34;Map[Key, Result]&#34;:
        &#34;&#34;&#34;Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection. The key passed to the function indicates the key of
        element being transformed.

        Args:
            mapping: The function to transform the key/value pairs

        Returns:
            The resulting map of keys and transformed values.
        &#34;&#34;&#34;
        return Map(maptree.map(mapping, self._tree))

    def partition(self, predicate: Callable[[Key, Value], bool]) -&gt; &#34;Tuple[Map[Key, Value], Map[Key, Value]]&#34;:
        r1, r2 = maptree.partition(predicate, self._tree)
        return Map(r1), Map(r2)

    def contains_key(self, key: Key) -&gt; bool:
        return maptree.mem(key, self._tree)

    def remove(self, key: Key) -&gt; &#34;Map[Key, Value]&#34;:
        return Map(maptree.remove(key, self._tree))

    def try_get_value(self, key: Key, value: List[Value]):
        for v in maptree.try_find(key, self._tree).to_list():
            value.append(v)
            return True
        else:
            return False

    def try_find(self, key: Key) -&gt; Option[Value]:
        return maptree.try_find(key, self._tree)

    def to_list(self) -&gt; FrozenList[Tuple[Key, Value]]:
        return maptree.to_list(self._tree)

    def to_seq(self) -&gt; Iterable[Tuple[Key, Value]]:
        &#34;&#34;&#34;Convert to sequence.

        Returns:
            Sequenc of key, value tuples.
        &#34;&#34;&#34;
        return maptree.to_seq(self._tree)

    @overload
    def of_list(lst: FrozenList[Tuple[Key, Value]]) -&gt; &#34;Map[Key, Value]&#34;:
        ...

    @overload
    def of_list(lst: List[Tuple[Key, Value]]) -&gt; &#34;Map[Key, Value]&#34;:
        ...

    @staticmethod
    def of_list(lst: Union[List[Tuple[Key, Value]], FrozenList[Tuple[Key, Value]]]) -&gt; &#34;Map[Key, Value]&#34;:
        &#34;&#34;&#34;Generate map from list.

        Returns:
            New map.
        &#34;&#34;&#34;
        return Map(maptree.of_list(FrozenList(lst)))

    def __hash__(self) -&gt; int:
        def combine_hash(x: int, y: int) -&gt; int:
            return (x &lt;&lt; 1) + y + 631

        res = 0
        for x, y in self:
            res = combine_hash(res, hash(x))
            res = combine_hash(res, hash(y))
        return res

    def __getitem__(self, key: Value) -&gt; Value:
        return maptree.find(key, self._tree)

    def __iter__(self) -&gt; Iterator[Tuple[Key, Value]]:
        return maptree.mk_iterator(self._tree)

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Return the number of bindings in the map.&#34;&#34;&#34;
        return maptree.size(self._tree)

    def __eq__(self, other: Any) -&gt; bool:
        if not isinstance(other, Map):
            return False

        other = cast(Map[Any, Any], other)
        iterator: Iterator[Tuple[Any, Any]] = iter(other.to_seq())

        for kv in self.to_seq():
            try:
                kv_other = next(iterator)
            except StopIteration:
                return False
            else:
                if kv != kv_other:
                    return False
        return True

    def __bool__(self) -&gt; bool:
        return maptree.is_empty(self._tree)

    def __str__(self) -&gt; str:
        def to_str(item: Tuple[Key, Value]) -&gt; str:
            key, value = item
            key = f&#39;&#34;{key}&#34;&#39; if isinstance(key, str) else key
            return f&#34;({key}, {value})&#34;

        items = pipe(self, Map.to_seq, seq.map(to_str))
        return f&#34;map [{&#39;; &#39;.join(items)}]&#34;

    def __repr__(self) -&gt; str:
        return str(self)


def add(key: Key, value: Value) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    &#34;&#34;&#34;Returns a new map with the binding added to the given map. If a
    binding with the given key already exists in the input map, the
    existing binding is replaced by the new binding in the result
    map.

    Args:
        key: The input key.
        value: The input value.
        table: The input table.

    Returns:
        The resulting map.
    &#34;&#34;&#34;

    def _add(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        return table.add(key, value)

    return _add


def change(key: Key, fn: Callable[[Option[Value]], Option[Value]]) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    &#34;&#34;&#34;Returns a new map with the value stored under key changed
    according to f.

    Args:
        key: The input key.
        fn: The change function.
        table: The input table.

    Returns:
        The input key.
    &#34;&#34;&#34;

    def _change(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        return table.change(key, fn)

    return _change


def count(table: Map[Key, Value]) -&gt; int:
    &#34;&#34;&#34;Return the number of bindings in the map.&#34;&#34;&#34;
    return len(table)


def find(key: Key) -&gt; Callable[[Map[Key, Value]], Value]:
    &#34;&#34;&#34;Lookup an element in the map, raising KeyNotFoundException if no
    binding exists in the map

    Args:
        key: The key to find.
        table: The map to find the key in.

    &#34;&#34;&#34;

    def _find(table: Map[Key, Value]) -&gt; Value:
        return table[key]

    return _find


def is_empty(table: Map[Key, Value]) -&gt; bool:
    &#34;&#34;&#34;Is the map empty?

    Args:
        table: The input map.

    Returns:
        True if the map is empty.
    &#34;&#34;&#34;
    return table.is_empty()


def contains_key(key: Key) -&gt; Callable[[Map[Key, Value]], bool]:
    def _contains_key(table: Map[Key, Value]) -&gt; bool:
        return table.contains_key(key)

    return _contains_key


def iterate(action: Callable[[Key, Value], None]) -&gt; Callable[[Map[Key, Value]], None]:
    def _iterate(table: Map[Key, Value]) -&gt; None:
        return table.iterate(action)

    return _iterate


def try_pick(chooser: Callable[[Key, Value], Option[Result]]) -&gt; Callable[[Map[Key, Value]], Option[Result]]:
    &#34;&#34;&#34;Searches the map looking for the first element where the given
    function returns a Some value.

    Args:
        chooser: The function to generate options from the key/value
            pairs.
    Returns:
        Partially applied `try_pick` function that takes the input map
        and returns the first result.
    &#34;&#34;&#34;

    def _try_pick(table: Map[Key, Value]) -&gt; Option[Result]:
        return table.try_pick(chooser)

    return _try_pick


def pick(chooser: Callable[[Key, Value], Option[Result]]) -&gt; Callable[[Map[Key, Value]], Option[Result]]:
    def _try_pick(table: Map[Key, Value]) -&gt; Option[Result]:
        for res in table.try_pick(chooser):
            return res
        else:
            raise KeyError()

    return _try_pick


def exists(predicate: Callable[[Key, Value], bool]) -&gt; Callable[[Map[Key, Value]], bool]:
    &#34;&#34;&#34;Returns true if the given predicate returns true for one of the bindings in the map.

    Args:
        predicate: The function to test the input elements.

    Returns:
        Partially applied function that takes a map table and returns
        true if the predicate returns true for one of the key/value
        pairs.
    &#34;&#34;&#34;

    def _exists(table: Map[Key, Value]) -&gt; bool:
        return table.exists(predicate)

    return _exists


def filter(predicate: Callable[[Key, Value], bool]) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    def _filter(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        return table.filter(predicate)

    return _filter


def for_all(predicate: Callable[[Key, Value], bool]) -&gt; Callable[[Map[Key, Value]], bool]:
    def _for_all(table: Map[Key, Value]) -&gt; bool:
        return table.for_all(predicate)

    return _for_all


def map(mapping: Callable[[Value], Result]) -&gt; Callable[[Map[Key, Value]], Map[Key, Result]]:
    def _map(table: Map[Key, Value]) -&gt; Map[Key, Result]:
        return table.map(mapping)

    return _map


def fold(folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) -&gt; Callable[[Map[Key, Value]], Result]:
    def _fold(table: Map[Key, Value]) -&gt; Result:
        return table.fold(folder, state)

    return _fold


# // [&lt;CompiledName(&#34;FoldBack&#34;)&gt;]
# let foldBack&lt;&#39;Key, &#39;T, &#39;State  when &#39;Key : comparison&gt; folder (table: Map&lt;&#39;Key, &#39;T&gt;) (state:&#39;State) =
#     maptree.foldBack folder table.Tree state


def partition(
    predicate: Callable[[Key, Value], bool]
) -&gt; Callable[[Map[Key, Value]], Tuple[Map[Key, Value], Map[Key, Value]]]:
    def _partition(table: Map[Key, Value]) -&gt; Tuple[Map[Key, Value], Map[Key, Value]]:
        return table.partition(predicate)

    return _partition


def remove(key: Key) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    &#34;&#34;&#34;Removes an element from the domain of the map. No exception is
    raised if the element is not present.

    Args:
        key: The key to remove.
        table: The table to remove the key from.

    Returns:
        The resulting map.
    &#34;&#34;&#34;

    def _remove(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        return table.remove(key)

    return _remove


def to_seq(table: Map[Key, Value]):
    return Map.to_seq(table)


# // [&lt;CompiledName(&#34;FindKey&#34;)&gt;]
# let findKey predicate (table : Map&lt;_, _&gt;) =
#     table |&gt; Seq.pick (fun kvp -&gt; let k = kvp.Key in if predicate k kvp.Value then Some k else None)

# // [&lt;CompiledName(&#34;TryFindKey&#34;)&gt;]
# let tryFindKey predicate (table : Map&lt;_, _&gt;) =
#     table |&gt; Seq.tryPick (fun kvp -&gt; let k = kvp.Key in if predicate k kvp.Value then Some k else None)


@overload
def of_list(elements: FrozenList[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    ...


@overload
def of_list(elements: List[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    ...


def of_list(elements: Union[List[Tuple[Key, Value]], FrozenList[Tuple[Key, Value]]]) -&gt; Map[Key, Value]:
    return Map.of_list(FrozenList(elements))


def of_seq(elements: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    return Map.create(elements)


def to_list(table: Map[Key, Value]) -&gt; FrozenList[Tuple[Key, Value]]:
    return table.to_list()


def try_find(key: Key) -&gt; Callable[[Map[Key, Value]], Option[Value]]:
    &#34;&#34;&#34;Lookup an element in the map, returning a `Some` value if the
    element is in the domain of the map and `Nothing` if not.

    Args:
        key: The input key.

    Returns:
        A partially applied `try_find` function that takes a map
        instance and returns the result.
    &#34;&#34;&#34;

    def _try_find(table: Map[Key, Value]):
        &#34;&#34;&#34;Lookup an element in the map, returning a `Some` value if the
        element is in the domain of the map and `Nothing` if not.

        Args:
            key: The input key.

        Returns:
            The found `Some` value or `Nothing`.
        &#34;&#34;&#34;
        return table.try_find(key)

    return _try_find


empty = Map.empty

# let groupBy (projection: &#39;T -&gt; &#39;Key) (xs: &#39;T seq) ([&lt;Fable.Core.Inject&gt;] comparer: IEqualityComparer&lt;&#39;Key&gt;): (&#39;Key * &#39;T seq) seq =
#     let dict: Fable.Core.JS.Map&lt;_,ResizeArray&lt;&#39;T&gt;&gt; = createMutable Seq.empty comparer

#     // Build the groupings
#     for v in xs do
#         let key = projection v
#         if dict.has(key) then dict.get(key).Add(v)
#         else dict.set(key, ResizeArray [v]) |&gt; ignore

#     // Mapping shouldn&#39;t be necessary because KeyValuePair compiles
#     // as a tuple, but let&#39;s do it just in case the implementation changes
#     dict.entries() |&gt; Seq.map (fun (k,v) -&gt; k, upcast v)

# let countBy (projection: &#39;T -&gt; &#39;Key) (xs: &#39;T seq) ([&lt;Fable.Core.Inject&gt;] comparer: IEqualityComparer&lt;&#39;Key&gt;): (&#39;Key * int) seq =
#     let dict = createMutable Seq.empty comparer

#     for value in xs do
#         let key = projection value
#         if dict.has(key) then dict.set(key, dict.get(key) + 1)
#         else dict.set(key, 1)
#         |&gt; ignore

#     dict.entries()


__all__ = [
    &#34;Map&#34;,
    &#34;add&#34;,
    &#34;change&#34;,
    &#34;contains_key&#34;,
    &#34;count&#34;,
    &#34;empty&#34;,
    &#34;exists&#34;,
    &#34;filter&#34;,
    &#34;find&#34;,
    &#34;fold&#34;,
    &#34;for_all&#34;,
    &#34;is_empty&#34;,
    &#34;iterate&#34;,
    &#34;map&#34;,
    &#34;of_list&#34;,
    &#34;partition&#34;,
    &#34;pick&#34;,
    &#34;remove&#34;,
    &#34;to_list&#34;,
    &#34;to_seq&#34;,
    &#34;try_find&#34;,
    &#34;try_pick&#34;,
]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="expression.collections.map.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>key: ~Key, value: ~Value) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new map with the binding added to the given map. If a
binding with the given key already exists in the input map, the
existing binding is replaced by the new binding in the result
map.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>The input key.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The input value.</dd>
<dt><strong><code>table</code></strong></dt>
<dd>The input table.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The resulting map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(key: Key, value: Value) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    &#34;&#34;&#34;Returns a new map with the binding added to the given map. If a
    binding with the given key already exists in the input map, the
    existing binding is replaced by the new binding in the result
    map.

    Args:
        key: The input key.
        value: The input value.
        table: The input table.

    Returns:
        The resulting map.
    &#34;&#34;&#34;

    def _add(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        return table.add(key, value)

    return _add</code></pre>
</details>
</dd>
<dt id="expression.collections.map.change"><code class="name flex">
<span>def <span class="ident">change</span></span>(<span>key: ~Key, fn: Callable[[<a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Value]], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Value]]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new map with the value stored under key changed
according to f.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>The input key.</dd>
<dt><strong><code>fn</code></strong></dt>
<dd>The change function.</dd>
<dt><strong><code>table</code></strong></dt>
<dd>The input table.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The input key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change(key: Key, fn: Callable[[Option[Value]], Option[Value]]) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    &#34;&#34;&#34;Returns a new map with the value stored under key changed
    according to f.

    Args:
        key: The input key.
        fn: The change function.
        table: The input table.

    Returns:
        The input key.
    &#34;&#34;&#34;

    def _change(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        return table.change(key, fn)

    return _change</code></pre>
</details>
</dd>
<dt id="expression.collections.map.contains_key"><code class="name flex">
<span>def <span class="ident">contains_key</span></span>(<span>key: ~Key) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_key(key: Key) -&gt; Callable[[Map[Key, Value]], bool]:
    def _contains_key(table: Map[Key, Value]) -&gt; bool:
        return table.contains_key(key)

    return _contains_key</code></pre>
</details>
</dd>
<dt id="expression.collections.map.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>table: <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Return the number of bindings in the map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(table: Map[Key, Value]) -&gt; int:
    &#34;&#34;&#34;Return the number of bindings in the map.&#34;&#34;&#34;
    return len(table)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def empty() -&gt; &#34;Map[Key, Value]&#34;:
    return Map(maptree.empty)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>predicate: Callable[[~Key, ~Value], bool]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the given predicate returns true for one of the bindings in the map.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>predicate</code></strong></dt>
<dd>The function to test the input elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Partially applied function that takes a map table and returns
true if the predicate returns true for one of the key/value
pairs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(predicate: Callable[[Key, Value], bool]) -&gt; Callable[[Map[Key, Value]], bool]:
    &#34;&#34;&#34;Returns true if the given predicate returns true for one of the bindings in the map.

    Args:
        predicate: The function to test the input elements.

    Returns:
        Partially applied function that takes a map table and returns
        true if the predicate returns true for one of the key/value
        pairs.
    &#34;&#34;&#34;

    def _exists(table: Map[Key, Value]) -&gt; bool:
        return table.exists(predicate)

    return _exists</code></pre>
</details>
</dd>
<dt id="expression.collections.map.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>predicate: Callable[[~Key, ~Value], bool]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(predicate: Callable[[Key, Value], bool]) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    def _filter(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        return table.filter(predicate)

    return _filter</code></pre>
</details>
</dd>
<dt id="expression.collections.map.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>key: ~Key) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], ~Value]</span>
</code></dt>
<dd>
<div class="desc"><p>Lookup an element in the map, raising KeyNotFoundException if no
binding exists in the map</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>The key to find.</dd>
<dt><strong><code>table</code></strong></dt>
<dd>The map to find the key in.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(key: Key) -&gt; Callable[[Map[Key, Value]], Value]:
    &#34;&#34;&#34;Lookup an element in the map, raising KeyNotFoundException if no
    binding exists in the map

    Args:
        key: The key to find.
        table: The map to find the key in.

    &#34;&#34;&#34;

    def _find(table: Map[Key, Value]) -&gt; Value:
        return table[key]

    return _find</code></pre>
</details>
</dd>
<dt id="expression.collections.map.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>folder: Callable[[~Result, Tuple[~Key, ~Value]], ~Result], state: ~Result) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], ~Result]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) -&gt; Callable[[Map[Key, Value]], Result]:
    def _fold(table: Map[Key, Value]) -&gt; Result:
        return table.fold(folder, state)

    return _fold</code></pre>
</details>
</dd>
<dt id="expression.collections.map.for_all"><code class="name flex">
<span>def <span class="ident">for_all</span></span>(<span>predicate: Callable[[~Key, ~Value], bool]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def for_all(predicate: Callable[[Key, Value], bool]) -&gt; Callable[[Map[Key, Value]], bool]:
    def _for_all(table: Map[Key, Value]) -&gt; bool:
        return table.for_all(predicate)

    return _for_all</code></pre>
</details>
</dd>
<dt id="expression.collections.map.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>table: <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Is the map empty?</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>table</code></strong></dt>
<dd>The input map.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the map is empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(table: Map[Key, Value]) -&gt; bool:
    &#34;&#34;&#34;Is the map empty?

    Args:
        table: The input map.

    Returns:
        True if the map is empty.
    &#34;&#34;&#34;
    return table.is_empty()</code></pre>
</details>
</dd>
<dt id="expression.collections.map.iterate"><code class="name flex">
<span>def <span class="ident">iterate</span></span>(<span>action: Callable[[~Key, ~Value], NoneType]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterate(action: Callable[[Key, Value], None]) -&gt; Callable[[Map[Key, Value]], None]:
    def _iterate(table: Map[Key, Value]) -&gt; None:
        return table.iterate(action)

    return _iterate</code></pre>
</details>
</dd>
<dt id="expression.collections.map.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>mapping: Callable[[~Value], ~Result]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Result]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(mapping: Callable[[Value], Result]) -&gt; Callable[[Map[Key, Value]], Map[Key, Result]]:
    def _map(table: Map[Key, Value]) -&gt; Map[Key, Result]:
        return table.map(mapping)

    return _map</code></pre>
</details>
</dd>
<dt id="expression.collections.map.of_list"><code class="name flex">
<span>def <span class="ident">of_list</span></span>(<span>elements: Union[List[Tuple[~Key, ~Value]], <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[Tuple[~Key, ~Value]]]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def of_list(elements: Union[List[Tuple[Key, Value]], FrozenList[Tuple[Key, Value]]]) -&gt; Map[Key, Value]:
    return Map.of_list(FrozenList(elements))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.partition"><code class="name flex">
<span>def <span class="ident">partition</span></span>(<span>predicate: Callable[[~Key, ~Value], bool]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], Tuple[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value], <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition(
    predicate: Callable[[Key, Value], bool]
) -&gt; Callable[[Map[Key, Value]], Tuple[Map[Key, Value], Map[Key, Value]]]:
    def _partition(table: Map[Key, Value]) -&gt; Tuple[Map[Key, Value], Map[Key, Value]]:
        return table.partition(predicate)

    return _partition</code></pre>
</details>
</dd>
<dt id="expression.collections.map.pick"><code class="name flex">
<span>def <span class="ident">pick</span></span>(<span>chooser: Callable[[~Key, ~Value], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Result]]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Result]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pick(chooser: Callable[[Key, Value], Option[Result]]) -&gt; Callable[[Map[Key, Value]], Option[Result]]:
    def _try_pick(table: Map[Key, Value]) -&gt; Option[Result]:
        for res in table.try_pick(chooser):
            return res
        else:
            raise KeyError()

    return _try_pick</code></pre>
</details>
</dd>
<dt id="expression.collections.map.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>key: ~Key) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"><p>Removes an element from the domain of the map. No exception is
raised if the element is not present.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>The key to remove.</dd>
<dt><strong><code>table</code></strong></dt>
<dd>The table to remove the key from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The resulting map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(key: Key) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    &#34;&#34;&#34;Removes an element from the domain of the map. No exception is
    raised if the element is not present.

    Args:
        key: The key to remove.
        table: The table to remove the key from.

    Returns:
        The resulting map.
    &#34;&#34;&#34;

    def _remove(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        return table.remove(key)

    return _remove</code></pre>
</details>
</dd>
<dt id="expression.collections.map.to_list"><code class="name flex">
<span>def <span class="ident">to_list</span></span>(<span>table: <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[typing.Tuple[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_list(table: Map[Key, Value]) -&gt; FrozenList[Tuple[Key, Value]]:
    return table.to_list()</code></pre>
</details>
</dd>
<dt id="expression.collections.map.to_seq"><code class="name flex">
<span>def <span class="ident">to_seq</span></span>(<span>table: <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_seq(table: Map[Key, Value]):
    return Map.to_seq(table)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.try_find"><code class="name flex">
<span>def <span class="ident">try_find</span></span>(<span>key: ~Key) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Value]]</span>
</code></dt>
<dd>
<div class="desc"><p>Lookup an element in the map, returning a <code>Some</code> value if the
element is in the domain of the map and <code>Nothing</code> if not.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>The input key.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A partially applied <code><a title="expression.collections.map.try_find" href="#expression.collections.map.try_find">try_find()</a></code> function that takes a map
instance and returns the result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_find(key: Key) -&gt; Callable[[Map[Key, Value]], Option[Value]]:
    &#34;&#34;&#34;Lookup an element in the map, returning a `Some` value if the
    element is in the domain of the map and `Nothing` if not.

    Args:
        key: The input key.

    Returns:
        A partially applied `try_find` function that takes a map
        instance and returns the result.
    &#34;&#34;&#34;

    def _try_find(table: Map[Key, Value]):
        &#34;&#34;&#34;Lookup an element in the map, returning a `Some` value if the
        element is in the domain of the map and `Nothing` if not.

        Args:
            key: The input key.

        Returns:
            The found `Some` value or `Nothing`.
        &#34;&#34;&#34;
        return table.try_find(key)

    return _try_find</code></pre>
</details>
</dd>
<dt id="expression.collections.map.try_pick"><code class="name flex">
<span>def <span class="ident">try_pick</span></span>(<span>chooser: Callable[[~Key, ~Value], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Result]]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Result]]</span>
</code></dt>
<dd>
<div class="desc"><p>Searches the map looking for the first element where the given
function returns a Some value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>chooser</code></strong></dt>
<dd>The function to generate options from the key/value
pairs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Partially applied <code><a title="expression.collections.map.try_pick" href="#expression.collections.map.try_pick">try_pick()</a></code> function that takes the input map
and returns the first result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_pick(chooser: Callable[[Key, Value], Option[Result]]) -&gt; Callable[[Map[Key, Value]], Option[Result]]:
    &#34;&#34;&#34;Searches the map looking for the first element where the given
    function returns a Some value.

    Args:
        chooser: The function to generate options from the key/value
            pairs.
    Returns:
        Partially applied `try_pick` function that takes the input map
        and returns the first result.
    &#34;&#34;&#34;

    def _try_pick(table: Map[Key, Value]) -&gt; Option[Result]:
        return table.try_pick(chooser)

    return _try_pick</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="expression.collections.map.Map"><code class="flex name class">
<span>class <span class="ident">Map</span></span>
<span>(</span><span>**kw: ~Value)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>A generic type is typically declared by inheriting from
this class parameterized with one or more type variables.
For example, a generic mapping type might be defined as::</p>
<p>class Mapping(Generic[KT, VT]):
def <strong>getitem</strong>(self, key: KT) -&gt; VT:
&hellip;
# Etc.</p>
<p>This class can then be used as follows::</p>
<p>def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
try:
return mapping[key]
except KeyError:
return default</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Map(Generic[Key, Value]):
    def __init__(self, __tree: Optional[MapTree[Key, Value]] = None, **kw: Value) -&gt; None:
        tree: MapTree[str, Value] = maptree.of_seq(kw.items())
        self._tree = __tree if __tree is not None else tree

    @overload
    def pipe(self, __fn1: Callable[[&#34;Map[Key, Value]&#34;], Result]) -&gt; Result:
        ...

    @overload
    def pipe(self, __fn1: Callable[[&#34;Map[Key, Value]&#34;], T1], __fn2: Callable[[T1], T2]) -&gt; T2:
        ...

    @overload
    def pipe(
        self, __fn1: Callable[[&#34;Map[Key, Value]&#34;], T1], __fn2: Callable[[T1], T2], __fn3: Callable[[T2], T3]
    ) -&gt; T3:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;Map[Key, Value]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
    ) -&gt; T4:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;Map[Key, Value]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
    ) -&gt; T5:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;Map[Key, Value]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
        __fn6: Callable[[T5], T6],
    ) -&gt; T6:
        ...

    def pipe(self, *args: Any) -&gt; Any:
        &#34;&#34;&#34;Pipe map through the given functions.&#34;&#34;&#34;
        return pipe(self, *args)

    @staticmethod
    def empty() -&gt; &#34;Map[Key, Value]&#34;:
        return Map(maptree.empty)

    @staticmethod
    def create(ie: Iterable[Tuple[Key, Value]]) -&gt; &#34;Map[Key, Value]&#34;:
        return Map(maptree.of_seq(ie))

    def add(self, key: Key, value: Value) -&gt; &#34;Map[Key, Value]&#34;:
        return Map(maptree.add(key, value, self._tree))

    def change(self, key: Key, f: Callable[[Option[Value]], Option[Value]]) -&gt; &#34;Map[Key, Value]&#34;:
        return Map(maptree.change(key, f, self._tree))

    def is_empty(self) -&gt; bool:
        return maptree.is_empty(self._tree)

    def try_pick(self, chooser: Callable[[Key, Value], Option[Result]]) -&gt; Option[Result]:
        return maptree.try_pick(chooser, self._tree)

    def exists(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
        return maptree.exists(predicate, self._tree)

    def filter(self, predicate: Callable[[Key, Value], bool]) -&gt; &#34;Map[Key, Value]&#34;:
        return Map(maptree.filter(predicate, self._tree))

    def for_all(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
        &#34;&#34;&#34;Returns true if the given predicate returns true for all of
        the bindings in the map.

        Args:
            predicate: The function to test the input elements.

        Returns:
            True if the predicate evaluates to true for all of the
            bindings in the map.
        &#34;&#34;&#34;
        return maptree.forall(predicate, self._tree)

    def iterate(self, f: Callable[[Key, Value], None]) -&gt; None:
        return maptree.iter(f, self._tree)

    #     def MapRange (f:&#39;Value-&gt;&#39;Result) =
    #         return Map&lt;&#39;Key, &#39;Result&gt;(comparer, maptree.map f tree)

    def fold(self, folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) -&gt; Result:
        return maptree.fold(folder, state, self._tree)

    def map(self, mapping: Callable[[Value], Result]) -&gt; &#34;Map[Key, Result]&#34;:
        &#34;&#34;&#34;Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection. The key passed to the function indicates the key of
        element being transformed.

        Args:
            mapping: The function to transform the key/value pairs

        Returns:
            The resulting map of keys and transformed values.
        &#34;&#34;&#34;
        return Map(maptree.map(mapping, self._tree))

    def partition(self, predicate: Callable[[Key, Value], bool]) -&gt; &#34;Tuple[Map[Key, Value], Map[Key, Value]]&#34;:
        r1, r2 = maptree.partition(predicate, self._tree)
        return Map(r1), Map(r2)

    def contains_key(self, key: Key) -&gt; bool:
        return maptree.mem(key, self._tree)

    def remove(self, key: Key) -&gt; &#34;Map[Key, Value]&#34;:
        return Map(maptree.remove(key, self._tree))

    def try_get_value(self, key: Key, value: List[Value]):
        for v in maptree.try_find(key, self._tree).to_list():
            value.append(v)
            return True
        else:
            return False

    def try_find(self, key: Key) -&gt; Option[Value]:
        return maptree.try_find(key, self._tree)

    def to_list(self) -&gt; FrozenList[Tuple[Key, Value]]:
        return maptree.to_list(self._tree)

    def to_seq(self) -&gt; Iterable[Tuple[Key, Value]]:
        &#34;&#34;&#34;Convert to sequence.

        Returns:
            Sequenc of key, value tuples.
        &#34;&#34;&#34;
        return maptree.to_seq(self._tree)

    @overload
    def of_list(lst: FrozenList[Tuple[Key, Value]]) -&gt; &#34;Map[Key, Value]&#34;:
        ...

    @overload
    def of_list(lst: List[Tuple[Key, Value]]) -&gt; &#34;Map[Key, Value]&#34;:
        ...

    @staticmethod
    def of_list(lst: Union[List[Tuple[Key, Value]], FrozenList[Tuple[Key, Value]]]) -&gt; &#34;Map[Key, Value]&#34;:
        &#34;&#34;&#34;Generate map from list.

        Returns:
            New map.
        &#34;&#34;&#34;
        return Map(maptree.of_list(FrozenList(lst)))

    def __hash__(self) -&gt; int:
        def combine_hash(x: int, y: int) -&gt; int:
            return (x &lt;&lt; 1) + y + 631

        res = 0
        for x, y in self:
            res = combine_hash(res, hash(x))
            res = combine_hash(res, hash(y))
        return res

    def __getitem__(self, key: Value) -&gt; Value:
        return maptree.find(key, self._tree)

    def __iter__(self) -&gt; Iterator[Tuple[Key, Value]]:
        return maptree.mk_iterator(self._tree)

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Return the number of bindings in the map.&#34;&#34;&#34;
        return maptree.size(self._tree)

    def __eq__(self, other: Any) -&gt; bool:
        if not isinstance(other, Map):
            return False

        other = cast(Map[Any, Any], other)
        iterator: Iterator[Tuple[Any, Any]] = iter(other.to_seq())

        for kv in self.to_seq():
            try:
                kv_other = next(iterator)
            except StopIteration:
                return False
            else:
                if kv != kv_other:
                    return False
        return True

    def __bool__(self) -&gt; bool:
        return maptree.is_empty(self._tree)

    def __str__(self) -&gt; str:
        def to_str(item: Tuple[Key, Value]) -&gt; str:
            key, value = item
            key = f&#39;&#34;{key}&#34;&#39; if isinstance(key, str) else key
            return f&#34;({key}, {value})&#34;

        items = pipe(self, Map.to_seq, seq.map(to_str))
        return f&#34;map [{&#39;; &#39;.join(items)}]&#34;

    def __repr__(self) -&gt; str:
        return str(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="expression.collections.map.Map.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>ie: Iterable[Tuple[~Key, ~Value]]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create(ie: Iterable[Tuple[Key, Value]]) -&gt; &#34;Map[Key, Value]&#34;:
    return Map(maptree.of_seq(ie))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def empty() -&gt; &#34;Map[Key, Value]&#34;:
    return Map(maptree.empty)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.of_list"><code class="name flex">
<span>def <span class="ident">of_list</span></span>(<span>lst: Union[List[Tuple[~Key, ~Value]], <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[Tuple[~Key, ~Value]]]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate map from list.</p>
<h2 id="returns">Returns</h2>
<p>New map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def of_list(lst: Union[List[Tuple[Key, Value]], FrozenList[Tuple[Key, Value]]]) -&gt; &#34;Map[Key, Value]&#34;:
    &#34;&#34;&#34;Generate map from list.

    Returns:
        New map.
    &#34;&#34;&#34;
    return Map(maptree.of_list(FrozenList(lst)))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="expression.collections.map.Map.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, key: ~Key, value: ~Value) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, key: Key, value: Value) -&gt; &#34;Map[Key, Value]&#34;:
    return Map(maptree.add(key, value, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.change"><code class="name flex">
<span>def <span class="ident">change</span></span>(<span>self, key: ~Key, f: Callable[[<a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Value]], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Value]]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change(self, key: Key, f: Callable[[Option[Value]], Option[Value]]) -&gt; &#34;Map[Key, Value]&#34;:
    return Map(maptree.change(key, f, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.contains_key"><code class="name flex">
<span>def <span class="ident">contains_key</span></span>(<span>self, key: ~Key) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_key(self, key: Key) -&gt; bool:
    return maptree.mem(key, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>self, predicate: Callable[[~Key, ~Value], bool]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
    return maptree.exists(predicate, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, predicate: Callable[[~Key, ~Value], bool]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, predicate: Callable[[Key, Value], bool]) -&gt; &#34;Map[Key, Value]&#34;:
    return Map(maptree.filter(predicate, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>self, folder: Callable[[~Result, Tuple[~Key, ~Value]], ~Result], state: ~Result) ‑> ~Result</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(self, folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) -&gt; Result:
    return maptree.fold(folder, state, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.for_all"><code class="name flex">
<span>def <span class="ident">for_all</span></span>(<span>self, predicate: Callable[[~Key, ~Value], bool]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the given predicate returns true for all of
the bindings in the map.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>predicate</code></strong></dt>
<dd>The function to test the input elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the predicate evaluates to true for all of the
bindings in the map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def for_all(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
    &#34;&#34;&#34;Returns true if the given predicate returns true for all of
    the bindings in the map.

    Args:
        predicate: The function to test the input elements.

    Returns:
        True if the predicate evaluates to true for all of the
        bindings in the map.
    &#34;&#34;&#34;
    return maptree.forall(predicate, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self) -&gt; bool:
    return maptree.is_empty(self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.iterate"><code class="name flex">
<span>def <span class="ident">iterate</span></span>(<span>self, f: Callable[[~Key, ~Value], NoneType]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterate(self, f: Callable[[Key, Value], None]) -&gt; None:
    return maptree.iter(f, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, mapping: Callable[[~Value], ~Result]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Result]</span>
</code></dt>
<dd>
<div class="desc"><p>Builds a new collection whose elements are the results of
applying the given function to each of the elements of the
collection. The key passed to the function indicates the key of
element being transformed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>The function to transform the key/value pairs</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The resulting map of keys and transformed values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, mapping: Callable[[Value], Result]) -&gt; &#34;Map[Key, Result]&#34;:
    &#34;&#34;&#34;Builds a new collection whose elements are the results of
    applying the given function to each of the elements of the
    collection. The key passed to the function indicates the key of
    element being transformed.

    Args:
        mapping: The function to transform the key/value pairs

    Returns:
        The resulting map of keys and transformed values.
    &#34;&#34;&#34;
    return Map(maptree.map(mapping, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.partition"><code class="name flex">
<span>def <span class="ident">partition</span></span>(<span>self, predicate: Callable[[~Key, ~Value], bool]) ‑> Tuple[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value], <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition(self, predicate: Callable[[Key, Value], bool]) -&gt; &#34;Tuple[Map[Key, Value], Map[Key, Value]]&#34;:
    r1, r2 = maptree.partition(predicate, self._tree)
    return Map(r1), Map(r2)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>self, *args: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Pipe map through the given functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipe(self, *args: Any) -&gt; Any:
    &#34;&#34;&#34;Pipe map through the given functions.&#34;&#34;&#34;
    return pipe(self, *args)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, key: ~Key) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, key: Key) -&gt; &#34;Map[Key, Value]&#34;:
    return Map(maptree.remove(key, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.to_list"><code class="name flex">
<span>def <span class="ident">to_list</span></span>(<span>self) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[typing.Tuple[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_list(self) -&gt; FrozenList[Tuple[Key, Value]]:
    return maptree.to_list(self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.to_seq"><code class="name flex">
<span>def <span class="ident">to_seq</span></span>(<span>self) ‑> Iterable[Tuple[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert to sequence.</p>
<h2 id="returns">Returns</h2>
<p>Sequenc of key, value tuples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_seq(self) -&gt; Iterable[Tuple[Key, Value]]:
    &#34;&#34;&#34;Convert to sequence.

    Returns:
        Sequenc of key, value tuples.
    &#34;&#34;&#34;
    return maptree.to_seq(self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.try_find"><code class="name flex">
<span>def <span class="ident">try_find</span></span>(<span>self, key: ~Key) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Value]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_find(self, key: Key) -&gt; Option[Value]:
    return maptree.try_find(key, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.try_get_value"><code class="name flex">
<span>def <span class="ident">try_get_value</span></span>(<span>self, key: ~Key, value: List[~Value])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_get_value(self, key: Key, value: List[Value]):
    for v in maptree.try_find(key, self._tree).to_list():
        value.append(v)
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.try_pick"><code class="name flex">
<span>def <span class="ident">try_pick</span></span>(<span>self, chooser: Callable[[~Key, ~Value], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Result]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Result]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_pick(self, chooser: Callable[[Key, Value], Option[Result]]) -&gt; Option[Result]:
    return maptree.try_pick(chooser, self._tree)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="expression.collections" href="index.html">expression.collections</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="expression.collections.map.add" href="#expression.collections.map.add">add</a></code></li>
<li><code><a title="expression.collections.map.change" href="#expression.collections.map.change">change</a></code></li>
<li><code><a title="expression.collections.map.contains_key" href="#expression.collections.map.contains_key">contains_key</a></code></li>
<li><code><a title="expression.collections.map.count" href="#expression.collections.map.count">count</a></code></li>
<li><code><a title="expression.collections.map.empty" href="#expression.collections.map.empty">empty</a></code></li>
<li><code><a title="expression.collections.map.exists" href="#expression.collections.map.exists">exists</a></code></li>
<li><code><a title="expression.collections.map.filter" href="#expression.collections.map.filter">filter</a></code></li>
<li><code><a title="expression.collections.map.find" href="#expression.collections.map.find">find</a></code></li>
<li><code><a title="expression.collections.map.fold" href="#expression.collections.map.fold">fold</a></code></li>
<li><code><a title="expression.collections.map.for_all" href="#expression.collections.map.for_all">for_all</a></code></li>
<li><code><a title="expression.collections.map.is_empty" href="#expression.collections.map.is_empty">is_empty</a></code></li>
<li><code><a title="expression.collections.map.iterate" href="#expression.collections.map.iterate">iterate</a></code></li>
<li><code><a title="expression.collections.map.map" href="#expression.collections.map.map">map</a></code></li>
<li><code><a title="expression.collections.map.of_list" href="#expression.collections.map.of_list">of_list</a></code></li>
<li><code><a title="expression.collections.map.partition" href="#expression.collections.map.partition">partition</a></code></li>
<li><code><a title="expression.collections.map.pick" href="#expression.collections.map.pick">pick</a></code></li>
<li><code><a title="expression.collections.map.remove" href="#expression.collections.map.remove">remove</a></code></li>
<li><code><a title="expression.collections.map.to_list" href="#expression.collections.map.to_list">to_list</a></code></li>
<li><code><a title="expression.collections.map.to_seq" href="#expression.collections.map.to_seq">to_seq</a></code></li>
<li><code><a title="expression.collections.map.try_find" href="#expression.collections.map.try_find">try_find</a></code></li>
<li><code><a title="expression.collections.map.try_pick" href="#expression.collections.map.try_pick">try_pick</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></code></h4>
<ul class="two-column">
<li><code><a title="expression.collections.map.Map.add" href="#expression.collections.map.Map.add">add</a></code></li>
<li><code><a title="expression.collections.map.Map.change" href="#expression.collections.map.Map.change">change</a></code></li>
<li><code><a title="expression.collections.map.Map.contains_key" href="#expression.collections.map.Map.contains_key">contains_key</a></code></li>
<li><code><a title="expression.collections.map.Map.create" href="#expression.collections.map.Map.create">create</a></code></li>
<li><code><a title="expression.collections.map.Map.empty" href="#expression.collections.map.Map.empty">empty</a></code></li>
<li><code><a title="expression.collections.map.Map.exists" href="#expression.collections.map.Map.exists">exists</a></code></li>
<li><code><a title="expression.collections.map.Map.filter" href="#expression.collections.map.Map.filter">filter</a></code></li>
<li><code><a title="expression.collections.map.Map.fold" href="#expression.collections.map.Map.fold">fold</a></code></li>
<li><code><a title="expression.collections.map.Map.for_all" href="#expression.collections.map.Map.for_all">for_all</a></code></li>
<li><code><a title="expression.collections.map.Map.is_empty" href="#expression.collections.map.Map.is_empty">is_empty</a></code></li>
<li><code><a title="expression.collections.map.Map.iterate" href="#expression.collections.map.Map.iterate">iterate</a></code></li>
<li><code><a title="expression.collections.map.Map.map" href="#expression.collections.map.Map.map">map</a></code></li>
<li><code><a title="expression.collections.map.Map.of_list" href="#expression.collections.map.Map.of_list">of_list</a></code></li>
<li><code><a title="expression.collections.map.Map.partition" href="#expression.collections.map.Map.partition">partition</a></code></li>
<li><code><a title="expression.collections.map.Map.pipe" href="#expression.collections.map.Map.pipe">pipe</a></code></li>
<li><code><a title="expression.collections.map.Map.remove" href="#expression.collections.map.Map.remove">remove</a></code></li>
<li><code><a title="expression.collections.map.Map.to_list" href="#expression.collections.map.Map.to_list">to_list</a></code></li>
<li><code><a title="expression.collections.map.Map.to_seq" href="#expression.collections.map.Map.to_seq">to_seq</a></code></li>
<li><code><a title="expression.collections.map.Map.try_find" href="#expression.collections.map.Map.try_find">try_find</a></code></li>
<li><code><a title="expression.collections.map.Map.try_get_value" href="#expression.collections.map.Map.try_get_value">try_get_value</a></code></li>
<li><code><a title="expression.collections.map.Map.try_pick" href="#expression.collections.map.Map.try_pick">try_pick</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>